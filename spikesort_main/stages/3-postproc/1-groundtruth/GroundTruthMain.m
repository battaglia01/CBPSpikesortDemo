%% ----------------------------------------------------------------------------------
% Post-analysis: Comparison of CBP to clustering results, and to ground truth (if
% available)

%** indicate which cells match ground truth.

function GroundTruthMain
global CBPdata params CBPInternals;


%% ---------------------------------------------------
% First check if there is ground truth data at all. If not, return
if ~isfield(CBPdata, 'ground_truth') || ...
   ~isfield(CBPdata.ground_truth, 'true_spike_times') || ...
   ~isfield(CBPdata.ground_truth, 'true_spike_class')
    fprintf('\nNOTE - file does not contain all ground truth information.\n')
    fprintf('As a result, some of the post-analysis materials, which require\n');
    fprintf('ground truth, will yield only partial information.\n\n');

    % if these materials aren't all there, just create blank templates for
    % all of them
    CBPdata.ground_truth = [];
    CBPdata.ground_truth.true_spike_times = [];
    CBPdata.ground_truth.true_spike_class = [];
    CBPdata.ground_truth.blank_ground_truth = true;

    %%@ CHECK THIS EXISTS!
end

CBPdata.ground_truth.blank_ground_truth = false;
%% ---------------------------------------------------
% If there is ground truth in the file, it is formatted as two arrays:
%   1. the `CBPdata.ground_truth.true_spike_times` object, which has true spike
%      times
%   2. the `CBPdata.ground_truth.true_spike_class` object, which has a spike id #
%      for each corresponding entry in the `true_spike_times` object
%
% For now, we assume that the `true_spike_class` object has spike ID's which are
% natural numbers greater than 1.
%
% As a first step, we are going to reformat this as a cell array, in which
% the n'th entry in the array is the vector of spike times for spike ID #n.
% We will later permute the entries so that the ground truth IDs match
% the clustering IDs in the best possible way.
%
% Also, if during the filtering stage, some group delay was added to the signal,
% that is removed here.
CBPdata.ground_truth.spike_time_array_processed = ...
    GetSpikeTimeCellArrayFromVectors(...
        CBPdata.ground_truth.true_spike_times, ...
        CBPdata.ground_truth.true_spike_class, ...
        CBPdata.filtering.sample_delay);

% Next, we need to determine which waveforms we're using as our "clustering" set.
% If this is imported from some external spike sorter (e.g. klusta), we want to
% use CBPdata.external. Otherwise, we use CBPdata.ground_truth.clustering. If
% CBPdata.external exists at all, we go with that.
if isfield(CBPdata, "external")
    CBPdata.ground_truth.clustering = CBPdata.external;
else
    CBPdata.ground_truth.clustering = CBPdata.clustering;
end

% Now, we have to determine which of our cell ID's match the ground truth ID's.
% Just because ground truth has a certain cell listed as ID #1 doesn't
% necessarily mean that it's going to best match cell ID #1 in our sorting
% thus far.
%
% This routine below determines how to best permute the ground truth ID numbers
% to match our sorting, using the spike times from both sets.
% In particular, we are using the clustering spike time array numbers as the
% standard to match the ground truth numbers to, which we then match with CBP
% later.
%
% Originally, this code changed the original ground_truth_true_spike_times
% and true_spike_class as well to match the new permutation. However, we
% will keep the originals as-is, for ease of comparison when saving, and
% instead only change the spike_time_array_processed array (which has
% already had its spike times shifted as well).
%
% This was the most intensive part of the ground truth calculations, but
% now the linear program we have has sped this up.
%
%%@ - In the future, maybe just have it do one of these to speed this up

%%
% First, do the clustering comparison
[CBPdata.ground_truth.best_ordering_cl, ...
 CBPdata.ground_truth.miss_mtx_cl, ...
 CBPdata.ground_truth.fp_mtx_cl, ...
 CBPdata.ground_truth.tp_mtx_cl, ...
 CBPdata.ground_truth.all_err_mtx_cl, ...
 CBPdata.ground_truth.total_score_mtx_cl] = ...
    ReorderCells( ...
        CBPdata.ground_truth.spike_time_array_processed, ...
        CBPdata.ground_truth.clustering.spike_time_array_cl, ...
        params.amplitude.spike_location_slack, ...
        params.ground_truth.balanced);

% and lastly, evaluate results
[CBPdata.ground_truth.total_misses_cl, ...
 CBPdata.ground_truth.total_false_positives_cl, ...
 CBPdata.ground_truth.total_true_positives_cl, ...
 CBPdata.ground_truth.misses_cl, ...
 CBPdata.ground_truth.false_positives_cl, ...
 CBPdata.ground_truth.true_positives_cl] = EvaluateSortingLowLevel(...
        CBPdata.ground_truth.clustering.spike_time_array_cl, ...
        CBPdata.ground_truth.spike_time_array_processed, ...
        CBPdata.ground_truth.best_ordering_cl, ...
        params.amplitude.spike_location_slack);

%%
% Then, do the CBP comparison
[CBPdata.ground_truth.best_ordering_cbp, ...
 CBPdata.ground_truth.miss_mtx_cbp, ...
 CBPdata.ground_truth.fp_mtx_cbp, ...
 CBPdata.ground_truth.tp_mtx_cbp, ...
 CBPdata.ground_truth.all_err_mtx_cbp, ...
 CBPdata.ground_truth.total_score_mtx_cbp] = ...
    ReorderCells(...
        CBPdata.ground_truth.spike_time_array_processed, ...
        CBPdata.waveform_refinement.spike_time_array_thresholded, ...
        params.amplitude.spike_location_slack, ...
        params.ground_truth.balanced);

[CBPdata.ground_truth.total_misses_cbp, ...
 CBPdata.ground_truth.total_false_positives_cbp, ...
 CBPdata.ground_truth.total_true_positives_cbp, ...
 CBPdata.ground_truth.misses_cbp, ...
 CBPdata.ground_truth.false_positives_cbp, ...
 CBPdata.ground_truth.true_positives_cbp] = EvaluateSortingLowLevel( ...
        CBPdata.waveform_refinement.spike_time_array_thresholded, ...
        CBPdata.ground_truth.spike_time_array_processed, ...
        CBPdata.ground_truth.best_ordering_cbp, ...
        params.amplitude.spike_location_slack);

%%@ Also create spike traces?


%%
% Now, we also get the "Assignment Triples" which we'll use repeatedly in
% the next few stages.
CBPdata.ground_truth.assignments = ...
    CalculateAssignmentTriples(...
        CBPdata.ground_truth.clustering.init_waveforms, ...
        CBPdata.waveform_refinement.final_waveforms, ...
        CBPdata.ground_truth.true_spike_waveforms, ...
        CBPdata.ground_truth.best_ordering_cl, ...
        CBPdata.ground_truth.best_ordering_cbp, ...
        CBPdata.waveform_refinement.cluster_assignment_mtx);


% Now have it print the evaluation results.
%%@ This just uses globals for now, and also stores some important results
%%@ in CBPdata.ground_truth - we can have it pass parameters later if we
%%@ want
PrintSortingEvaluationResults;
