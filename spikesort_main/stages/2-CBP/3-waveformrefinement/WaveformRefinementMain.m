%% ----------------------------------------------------------------------------------
% CBP Step 4: Re-estimate waveforms


function WaveformRefinementMain
global CBPdata params CBPInternals;

% Now that we've updated the thresholds, compute the final spike waveforms.
% Store in CBPdata.waveform_refinement
CBPdata.waveform_refinement = [];
CBPdata.waveform_refinement.final_waveforms = {};
CBPdata.waveform_refinement.num_waveforms = CBPdata.CBP.num_waveforms;

% Compute waveforms using regression, with interpolation (defaults to cubic spline)
nlrpoints = (params.general.spike_waveform_len-1)/2;
for n=1:length(CBPdata.CBP.spike_time_array)
    %%@ original left for reference. Why are we subtracting 1???
    %%@ sts = CBPdata.CBP.spike_time_array{n}(CBPdata.CBP.spike_amps{n} > ...
    %%@                                  CBPdata.amplitude.amp_thresholds(n)) - 1;
    %%@ CBPdata.CBP.final_waveforms{n} = CalcSTA(CBPdata.whitening.data', ...
    %%@                                              sts, [-nlrpoints nlrpoints])';

    % get a bitmask of all the spike indices that exceed threshold level
    amplitudemask = ...
        CBPdata.CBP.spike_amps{n} > CBPdata.amplitude.amp_thresholds(n);

    % get thresholded versions of spike times, amps, etc
    %%@ the {n,1} makes sure this is a column array
    CBPdata.waveform_refinement.spike_time_array_thresholded{n,1} = ...
        CBPdata.CBP.spike_time_array{n}(amplitudemask);
    CBPdata.waveform_refinement.spike_time_array_ms_thresholded{n,1} = ...
        CBPdata.CBP.spike_time_array_ms{n}(amplitudemask);
    CBPdata.waveform_refinement.spike_amps_thresholded{n,1} = ...
        CBPdata.CBP.spike_amps{n}(amplitudemask);

    % Do the interpolation and get the final waveforms
    %%@ Note the - 1 below in the second arg - this is the way it
    %%@ originally was, not sure why. Just leaving it like this.
    CBPdata.waveform_refinement.final_waveforms{n} = ...
        CalcSTA(CBPdata.whitening.data', ...
                CBPdata.waveform_refinement.spike_time_array_thresholded{n} - 1, ...
                [-nlrpoints nlrpoints]);
end

% create thresholded spike traces for use in postproc
CBPdata.waveform_refinement.spike_traces_thresholded = ...
    CreateSpikeTraces(CBPdata.waveform_refinement.spike_time_array_thresholded, ...
                      CBPdata.waveform_refinement.spike_amps_thresholded, ...
                      CBPdata.waveform_refinement.final_waveforms, ...
                      CBPdata.whitening.nsamples, ...
                      CBPdata.whitening.nchan);

% Develop single vectors of (rounded) sample times and assignments
[CBPdata.waveform_refinement.segment_centers, ...
 CBPdata.waveform_refinement.assignments] = ...
    GetSpikeVectorsFromTimeCellArray(...
        CBPdata.waveform_refinement.spike_time_array_thresholded);

% add PCs and so on
[CBPdata.waveform_refinement.X, ~, ...
 CBPdata.waveform_refinement.assignments, ...
 CBPdata.waveform_refinement.PCs, CBPdata.waveform_refinement.XProj, ~, ~] = ...
    GetAllSpikeInfo(...
        CBPdata.waveform_refinement.segment_centers, ...
        CBPdata.waveform_refinement.assignments, ...
        false);

% increment the number of passes to waveform refinement - should match CBP
CBPdata.waveform_refinement.num_passes = CBPdata.CBP.num_passes;

% Match waveforms. We need to do two levels of waveform matching: first to the
% pre-refined waveforms, and also to the original clusters.
% to clusters
CBPdata.waveform_refinement.cluster_assignment_mtx = ...
    MatchWaveforms(CBPdata.clustering.init_waveforms, ...
                   CBPdata.waveform_refinement.final_waveforms);
% to pre-refined waveforms
CBPdata.waveform_refinement.init_assignment_mtx = ...
    MatchWaveforms(CBPdata.CBP.init_waveforms, ...
                  CBPdata.waveform_refinement.final_waveforms);
